# Лабораторная работа №3 по Арихитектуре компьютера.

- Ерехинский Андрей Владимирович
- `asm | acc | neum | hw | instr | struct | trap | port | prob1 -`

## Язык программирования

``` ebnf
<program> ::= <program> <line> | <line>

<data> ::= <letter> | <number> | <data> <data>
<label> ::= ":"<label>":" | <label> <label> | <number> | <letter>

<opcode_without_arg> ::= "in" | "out" | "hlt" | "inc" | "dec"
<opcode_arg> ::= "add" | "mod" | "sub" | "ld_addr"| "cmp" | "st" | "ld_val" | "in" | "out"

<line> ::= <label> | <term> <label> | <opcode_arg> <data> | <opcode_without_arg>

<letter> ::= [a-z] | [A-Z]
<number> ::= [0-9] | <number> <number>
```

Описание:

* Поддержка меток вида :label:
* В коде две раздела :data: - раздел с данными, :start: - программа
* 2 типа данных char и number
* Ввод-вывод через команды in, out

Операнды:

* data прямая адресация
* label прямая адресация

## Организация памяти

Модель памяти процессора:

Память данных и команд совмещены. Машинное слово: <opcode> <argument>

## Система команд

| Syntax     | Кол-во тактов| Comment                                                              |
|:-----------|--------------|:---------------------------------------------------------------------|
| `in`       | 1,4          | `запись в acumulator из устройства ввода`                            |
| `out`  	 | 1,4          | `запись в стандартный поток вывода из acumulator(числа)`             |
| `hlt`      | 0            | `оставновка процессора`                                              |
| `add`      | 2            | `прибавить к acumulator операнд`                                     |
| `sub`      | 2            | `вычесть из acumulator операнд`                                      |
| `inc`      | 1            | `AC + 1`                                     						   |
| `dec`      | 1            | `AC - 1`                       									   |
| `mod`      | 2            | `остаток от деления acumulator`                                      |
| `cmp`      | 2            | `вычесть AC из операнд(регистр обновляется)` 						   |
| `st`       | 2            | `сохранить accumulator в память`                                     |
| `ld_val`   | 2            | `загрузить значение аргумента по адресу в acumulator`                |
| `ld_addr`  | 2            | `загрузить значение адреса в acumulator`                       	   |
| `jmp`      | 1            | `переход на метку`                                                   |
| `je`       | 1            | `переход на метку если AC = 0`                                       |

### Кодирование инструкций

* Машинный код сериализуется в список JSON.
* Один элемент списка, одна инструкция.
* Индекс списка -- адрес инструкции. Используется для команд перехода.

Пример:

```json
    {
        "term": [
            "ST",
            13
        ]
    },
```

где:

* 'term' -- слово
* первый элемент -- операция или принадлежность слово к данным
* второй элемент -- аргумент (может отсутствовать)

Типы данные в модуле [isa](./isa.py), где:

* `Opcode` -- перечисление кодов операций;
* `Register` -- перечисление используемых в операциях регистров
* `Term` -- структура для описания значимого фрагмента кода исходной программы.

## Транслятор

Реализовано в модуле [translator.py](./translator.py)

Транслирует код на языке ассемблера в машинные инструкции (json)

Пример кода prob1:

```
:data:
SUM 0
THREE 3
FIVE 5
CUR 0
NULL 0
END 1000
:start:
LD_VAL CUR
INC
ST CUR
CMP END
JE :exit:
LD_VAL CUR
MOD THREE
CMP NULL
JE :summ:
LD_VAL CUR
MOD FIVE
CMP NULL
JE :summ:
JMP :start:
:summ:
LD_VAL SUM
ADD CUR
ST SUM
JMP :start:
:exit:
LD_VAL SUM
OUT 1
HLT
```

Результат трансляции файл в json

```
[
    {
        "term": [
            "data",
            "0"
        ]
    },
    {
        "term": [
            "data",
            "3"
        ]
    },
    {
        "term": [
            "data",
            "5"
        ]
    },
    {
        "term": [
            "data",
            "0"
        ]
    },
    {
        "term": [
            "data",
            "0"
        ]
    },
    {
        "term": [
            "data",
            "1000"
        ]
    },
    {
        "term": [
            "LD_VAL",
            3
        ]
    },
    {
        "term": [
            "INC",
            []
        ]
    },
    {
        "term": [
            "ST",
            3
        ]
    },
    {
        "term": [
            "CMP",
            5
        ]
    },
    {
        "term": [
            "JE",
            24
        ]
    },
    {
        "term": [
            "LD_VAL",
            3
        ]
    },
    {
        "term": [
            "MOD",
            1
        ]
    },
    {
        "term": [
            "CMP",
            4
        ]
    },
    {
        "term": [
            "JE",
            20
        ]
    },
    {
        "term": [
            "LD_VAL",
            3
        ]
    },
    {
        "term": [
            "MOD",
            2
        ]
    },
    {
        "term": [
            "CMP",
            4
        ]
    },
    {
        "term": [
            "JE",
            20
        ]
    },
    {
        "term": [
            "JMP",
            6
        ]
    },
    {
        "term": [
            "LD_VAL",
            0
        ]
    },
    {
        "term": [
            "ADD",
            3
        ]
    },
    {
        "term": [
            "ST",
            0
        ]
    },
    {
        "term": [
            "JMP",
            6
        ]
    },
    {
        "term": [
            "LD_VAL",
            0
        ]
    },
    {
        "term": [
            "OUT",
            "1"
        ]
    },
    {
        "term": [
            "HLT",
            []
        ]
    }
]
```


## Модель процессора

Реализовано в модуле: [machine](./machine.py).

![processor model](processor.png)






Реализован в классе `DataPath`.

- `data_memory` -- однопортовая, поэтому либо читаем, либо пишем.
- `input` -- вызовет остановку процесса моделирования, если буфер входных значений закончился.

Сигналы (обрабатываются за один такт, реализованы в виде методов класса):

- `latch_data_addr` -- защёлкнуть выбранное значение в `data_addr`;
- `latch_acc` -- защёлкнуть в аккумулятор выход памяти данных;
- `output` -- записать аккумулятор в порт вывода (обработка на python);
- `wr` -- записать выбранное значение в память:
    - инкрементированное;
    - декрементированное;
    - с порта ввода (обработка на python).

Флаги:

- `zero` -- отражает наличие нулевого значения в аккумуляторе.

Реализован в классе `ControlUnit`.

- Hardwired (реализовано полностью на python).
- Моделирование на уровне инструкций.
- Трансляция инструкции в последовательность (0-2 такта) сигналов: `decode_and_execute_instruction`.
- `step_counter` необходим для многотактовых команд:
    - в классе `ControlUnit` отсутствует, т.к. моделирование производится на уровне инструкций.

Сигнал:

- `latch_program_counter` -- сигнал для обновления счётчика команд в ControlUnit.

Особенности работы модели:

- Для журнала состояний процессора используется стандартный модуль logging.
- Количество инструкций для моделирования ограничено hardcoded константой.
- Остановка моделирования осуществляется при помощи исключений:
    - `EOFError` -- если нет данных для чтения из порта ввода-вывода;
    - `StopIteration` -- если выполнена инструкция `halt`.
- Управление симуляцией реализовано в функции `simulate`.





## Апробация

В качестве тестов использовано три алгоритма:

1. [hello world](/hello.txt)
2. [cat](/cat.txt)
3. [prob1](/prob1.txt) 

Интеграционные тесты реализованы тут: [integration_test](./integration_test.py) в двух вариантах:

- через golden tests, конфигурация которых лежит в папке [golden](./golden) (рекомендуемый способ).
- через unittest (устаревший пример).


Пример использования и журнал работы процессора на примере `prob1`:

``` console
> ./simulator.py /src/asm_code/prob1.txt src/files/target.txt src/files/input.txt
source LoC: 56 code instr: 27
233168
instr_counter: 14065 ticks: 23465
> cat target.txt 

[
    {
        "term": [
            "data",
            "0"
        ]
    },
    {
        "term": [
            "data",
            "3"
        ]
    },
    {
        "term": [
            "data",
            "5"
        ]
    },
    {
        "term": [
            "data",
            "0"
        ]
    },
    {
        "term": [
            "data",
            "0"
        ]
    },
    {
        "term": [
            "data",
            "1000"
        ]
    },
    {
        "term": [
            "LD_VAL",
            3
        ]
    },
    {
        "term": [
            "INC",
            []
        ]
    },
    {
        "term": [
            "ST",
            3
        ]
    },
    {
        "term": [
            "CMP",
            5
        ]
    },
    {
        "term": [
            "JE",
            24
        ]
    },
    {
        "term": [
            "LD_VAL",
            3
        ]
    },
    {
        "term": [
            "MOD",
            1
        ]
    },
    {
        "term": [
            "CMP",
            4
        ]
    },
    {
        "term": [
            "JE",
            20
        ]
    },
    {
        "term": [
            "LD_VAL",
            3
        ]
    },
    {
        "term": [
            "MOD",
            2
        ]
    },
    {
        "term": [
            "CMP",
            4
        ]
    },
    {
        "term": [
            "JE",
            20
        ]
    },
    {
        "term": [
            "JMP",
            6
        ]
    },
    {
        "term": [
            "LD_VAL",
            0
        ]
    },
    {
        "term": [
            "ADD",
            3
        ]
    },
    {
        "term": [
            "ST",
            0
        ]
    },
    {
        "term": [
            "JMP",
            6
        ]
    },
    {
        "term": [
            "LD_VAL",
            0
        ]
    },
    {
        "term": [
            "OUT",
            "1"
        ]
    },
    {
        "term": [
            "HLT",
            []
        ]
    }
]

> cat debug.txt

[debug.txt](src/files/debug.txt)

```

source LoC: 22 code instr: 10
foo
instr_counter: 55 ticks: 97

source LoC: 57 code instr: 27
Hello World!
instr_counter: 197 ticks: 345

source LoC: 56 code instr: 27
233168
instr_counter: 14065 ticks: 23465

| ФИО                | Алгоритм | LoC | code байт | code инстр | инстр. | такт | вариант |
|--------------------|----------|-----|-----------|------------|--------|------|---------|
| Ерехинский Андрей    | hello    | 57  | -         | 27          | 197    | 345  | ...     |
| Ерехинский Андрей    | cat      | 22   | -         | 10          | 107651     | 161491   | ...     |
| Ерехинский Андрей    | prob1    | 56  | -         | 27         | 55    | 97 | ...     |
